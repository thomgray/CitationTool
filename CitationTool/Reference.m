//
//  Reference.m
//  CitationTool3
//
//  Created by Thomas Gray on 20/09/2015.
//  Copyright (c) 2015 Thomas Gray. All rights reserved.
//

#import "Reference.h"
#import "Parser.h"
#import "TeXTranslator.h"
#import <Cocoa/Cocoa.h>


@interface Reference(){
    NSMutableArray* orderedFieldKeys;
}

-(NSMutableArray*)getRawFieldArray:(NSString*)str;
-(NSMutableDictionary*)getFieldDictionary:(NSMutableArray*)array;
-(void)parseForFields:(NSString*) str;
-(NSMutableArray*)makeNameArray:(NSString*)str;

-(NSString*)getVolumeNumber;
-(NSString*)getPages;
-(NSString*)getTitle;
-(NSAttributedString*)refStubForArticle;
-(NSAttributedString*)refStubForBook;
-(NSString*)privateMakeTexString;

@end

@implementation Reference

-(instancetype)init{
    self = [super init];
    if (self) {
        keyAutoGenerated = TRUE;
        fields = [[NSMutableDictionary alloc]init];
        texFields = [[NSMutableDictionary alloc]init];
        keys = [[NSMutableArray alloc]initWithArray:[Reference getEstablishedFields]];
        key = @"";
        for (NSInteger i=0; i<keys.count; i++){
            NSString* field =[keys objectAtIndex:i];
            [fields setValue:@"" forKey:field];
            [texFields setValue:@"" forKey:field];
        }
        bibTexString = @"";
    }
    return self;
}

-(instancetype)initWithBibEntry:(NSString*)bibString{
    self = [super init];
    if (self) {
        keyAutoGenerated = TRUE;
        keys = [[NSMutableArray alloc]initWithArray:[Reference getEstablishedFields]];
        fields = [[NSMutableDictionary alloc]init];
        [self getDataFromBib:bibString];
    }
    return self;
}

@synthesize key;
@synthesize type;
@synthesize fields;
@synthesize texFields;
@synthesize keys;

@synthesize editorArray;
@synthesize authorArray;
@synthesize yearModifier;
@synthesize yearInt;
@synthesize keyAutoGenerated;


#pragma mark Initialising Methods

-(void)getDataFromBib:(NSString *)bibString {
    NSInteger i;
    bibString = [bibString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    if ([bibString characterAtIndex:0]=='@') bibString = [bibString substringFromIndex:1];
    bibTexString = [NSString stringWithFormat:@"@%@", bibString];
    
    for (i =0; TRUE; i++) {
        unichar c = [bibString characterAtIndex:i];
        if (c=='{') {
            break;
        }
    }
    
    NSString* typ = [[bibString substringToIndex:i] stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
    [self setType:[typ lowercaseString]];
    
    int lr=1;
    i++;
    NSInteger j;
    for (j=i; j<bibString.length; j++) {
        unichar c = [bibString characterAtIndex:j];
        if (c=='{') lr++;
        else if (c=='}') lr--;
        
        if (lr==0)break;
        else if (j==bibString.length-1)@throw [NSException exceptionWithName:@"Parse Exception" reason:@"No final brace" userInfo:nil];
    }
    NSString* theRestOfIt = [bibString substringWithRange:NSMakeRange(i, j-i)];
    [self parseForFields:theRestOfIt];
}

-(void) parseForFields:(NSString *)str{
    NSMutableArray* rawFields = [self getRawFieldArray:str];
    if (rawFields.count>0) {
        NSString* possKey = rawFields[0];
        if (![possKey containsString:@"="]) {
            key = possKey;
            [rawFields removeObject:possKey];
            keyAutoGenerated = FALSE;
        }
    }
    texFields = [self getFieldDictionary:rawFields];
    
    fields = [[NSMutableDictionary alloc] initWithCapacity:texFields.count];
    for (NSInteger i=0; i<texFields.allKeys.count; i++){
        NSString* ky =[texFields.allKeys objectAtIndex:i];
        NSString* val = [texFields valueForKey:ky];
        @try{
            val = [TeXTranslator translateTexToAttributedString:val].string;
        }@catch(NSException* e){}
        [fields setValue:val forKey:ky];
    }
    
    //fields = [self getFieldDictionary:rawFields];
    
    ///Initialize the custom properties:
    
    editorArray = [self makeNameArray:[fields valueForKey:EDITOR]];
    authorArray = [self makeNameArray:[fields valueForKey:AUTHOR]];
    if ([fields valueForKey:YEAR]) yearInt = [[fields valueForKey:YEAR] integerValue];
}

-(NSMutableArray*) getRawFieldArray:(NSString *)str{
    ///these are separated by commas, ignoring cases inside braces
    NSMutableArray* out = [[NSMutableArray alloc]init];
    int  lr=0;
    NSInteger m=0;
    for (NSInteger i =0; i<str.length; i++) {
        unichar c = [str characterAtIndex:i];
        if (c=='{') lr++;
        else if (c=='}') lr--;
        
        if (c==',' && lr==0){
            NSString* substring = [str substringWithRange:NSMakeRange(m, i-m)];
            substring = [substring stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            [out addObject:substring];
            m=i+1;
        }else if (i==str.length-1){
            NSString* substring = [str substringFromIndex:m];
            substring = [substring stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];
            [out addObject:substring];
        }
    }
    return out;
}

-(NSMutableDictionary*)getFieldDictionary:(NSMutableArray *)array{
    NSCharacterSet* empties= [NSCharacterSet whitespaceAndNewlineCharacterSet];
    NSMutableDictionary *out = [[NSMutableDictionary alloc]init];
    for (NSInteger i=0; i<keys.count; i++){
        NSString* field =[keys objectAtIndex:i];
        [out setObject:@"" forKey:field];
    }
    for (NSInteger i=0; i<array.count; i++){
        NSString* field =[array objectAtIndex:i];
        if (![field containsString:@"="]) continue;
        int i;
        for (i=0;i<field.length;i++)    if ([field characterAtIndex:i]=='=') break;
        NSString* fieldKey = [[field substringToIndex:i] stringByTrimmingCharactersInSet:empties];
        fieldKey = [fieldKey lowercaseString];
        NSString* fieldVal = [[field substringFromIndex:i+1]stringByTrimmingCharactersInSet:empties];
        fieldVal = [fieldVal substringWithRange:NSMakeRange(1, fieldVal.length-2)]; //to remove outside braces        
    
        [out setObject:fieldVal forKey:fieldKey];
        if (![keys containsObject:fieldKey]) [keys addObject:fieldKey];
    }
    return out;
}


+(NSInteger)getIndexOfFirst:(unichar)c inString:(NSString *)str{
    for (NSUInteger i =0; i<str.length; i++) {
        unichar d= [str characterAtIndex:i];
        if (c==d) {
            return i;
        }
    }
    return -1;
}

-(NSMutableArray*)makeNameArray:(NSString*)str{ //needs to account for other formats: e.g. `Hilary Putnam and others'
    if (!str) return nil;
    NSCharacterSet* empty = [NSCharacterSet whitespaceAndNewlineCharacterSet];
    
    NSArray* names1 = [str componentsSeparatedByString:@" and "];
    NSMutableArray * names2 = [[NSMutableArray alloc]init];
    NSMutableArray * out = [[NSMutableArray alloc]init];
    
    for (int i=0; i<names1.count;i++) {
        NSString* name = [names1 objectAtIndex:i];
        name = [name stringByTrimmingCharactersInSet:empty];
        if (name.length>0) [names2 addObject:name];
    }
    
    for (NSInteger k=0; k<names2.count; k++){
        NSString * name =[names2 objectAtIndex:k];
        Name *finalName = [Name getNameFromString:name];
        [out addObject:finalName];
    }
    return out;
}


-(BOOL) matchesCitation:(Citation *)cite{
    if (cite.authors.count > authorArray.count) return false;
    if (yearInt != cite.year.year) return false;
    for (int i=0; i<cite.authors.count; i++) {
        NSString* inSurname = [[cite.authors objectAtIndex:i]lowercaseString];
        Name* thisName = [authorArray objectAtIndex:i];
        NSString* thisSurname = [thisName.surname lowercaseString];
        
        if ((authorArray.count>i+1) && [inSurname isEqualToString:ET_AL]) break;
        if (![Name string:inSurname isAlphabeticallyIdenticalTo:thisSurname]) return FALSE;
    }
//    NSLog(@"Found a match: %@ ---matching with----- %@", [self.fields valueForKey:AUTHOR], [cite authorsStringWithFinalDelimiter:@"&"]);
    return true;
}

#pragma mark To String Methods

-(NSString*)toStringTypeTitle{
    NSString* out = [NSString stringWithFormat:@"(%@) %@", [type capitalizedString], [[fields valueForKey:TITLE]capitalizedString]];
    return out;
}

-(NSAttributedString *)getReferenceCompleteString{
    NSString*authyr = [self getAuthorsAndYear];
    authyr = [authyr stringByAppendingString:@" "];
    NSMutableAttributedString* out = [[NSMutableAttributedString alloc]initWithString:authyr];
    [out appendAttributedString:[self getReferenceStub]];
    return out;
}

-(NSAttributedString *)getReferenceStub{
    if ([type isEqualToString:ARTICLE]) {
        return [self refStubForArticle];
    }else if ([type isEqualToString:BOOK]){
        return [self refStubForBook];
    }
    return [[NSAttributedString alloc]initWithString:[self toStringTypeTitle]];
}

-(NSAttributedString *)refStubForArticle{
    NSMutableAttributedString* out = [[NSMutableAttributedString alloc]initWithString:[self getTitle]];
    NSString* journal = [[fields valueForKey:JOURNAL]capitalizedString];
    if (journal.length) {
        NSMutableAttributedString* journalStr = [[NSMutableAttributedString alloc]initWithString:journal];
        [journalStr applyFontTraits:NSItalicFontMask range:NSMakeRange(0, journal.length)];
        if (out.length) {
            [out appendAttributedString:[[NSAttributedString alloc]initWithString:@", "]];
        }
        [out appendAttributedString:journalStr];
    }
    NSMutableString* therest = [[NSMutableString alloc]initWithString:@""];
    NSString* vol = [self getVolumeNumber];
    if (vol) {
        [therest appendString:vol];
    }
    NSString* pages = [self getPages];
    if (pages) {
        if (therest.length) {
            [therest appendFormat:@", %@", pages];
        }else [therest appendString:pages];
    }
    
    [out appendAttributedString:[[NSAttributedString alloc]initWithString:@". "]];
    [out appendAttributedString:[[NSAttributedString alloc]initWithString:therest]];
    return out;
}

-(NSAttributedString *)refStubForBook{
    NSMutableAttributedString* out = [[NSMutableAttributedString alloc]initWithString:[[fields valueForKey:TITLE]capitalizedString]];
    [out applyFontTraits:NSItalicFontMask range:NSMakeRange(0, out.length)];
    [out appendAttributedString:[[NSAttributedString alloc]initWithString:@". "]];
    NSMutableString* therest = [[NSMutableString alloc]initWithString:@""];
    NSString* ed = [fields valueForKey:EDITION];
    if (ed.length) {
        NSInteger i = [ed integerValue];
        if (i==0) {
            [therest appendString:ed];
        }else if (i==1){
            [therest appendString:@"1st ed. "];
        }else if (i==2){
            [therest appendString:@"2nd ed. "];
        }else if (i==3){
            [therest appendString:@"3rd ed. "];
        }else{
            [therest appendFormat:@"%ldth ed. ", i];
        }
    }
    NSString* ad = [fields valueForKey:ADDRESS];
    NSString* pub = [fields valueForKey:PUBLISHER];
    if (pub.length && ad.length) {
        [therest appendFormat:@"%@:%@", ad, pub];
    }else if (ad.length){
        [therest appendString:ad];
    }else if (pub.length){
        [therest appendString:pub];
    }
    [out appendAttributedString:[[NSAttributedString alloc]initWithString:therest]];
    return out;
}

-(NSString *)getVolumeNumber{
    NSString* vol = [fields valueForKey:VOLUME];
    if (!vol.length) return nil;
    
    NSString* number = [fields valueForKey:NUMBER];
    if (number.length) {
        vol = [vol stringByAppendingFormat:@":%@", number];
    }
    return vol;
}

-(NSString *)getPages{
    NSString* pages = [fields valueForKey:PAGES];
    if (!pages.length) return nil;
    NSCharacterSet* numerals = [NSCharacterSet characterSetWithCharactersInString:@"0123456789"];
    if ([numerals characterIsMember:[pages characterAtIndex:0]]) {
        if ([pages containsString:@"-"]) {
            return [NSString stringWithFormat:@"pp.%@", pages];
        }else{
            return [NSString stringWithFormat:@"p.%@", pages];
        }
    }else{
        return pages;
    }
}

-(NSString *)getTitle{
    NSString* title = [[fields valueForKey:TITLE]capitalizedString];
    if (title.length==0) return title;
    title = [NSString stringWithFormat:@"'%@'", title];
    return title;
}

-(NSString *)getAuthorsAndYear{
    NSMutableString* out = [[NSMutableString alloc]initWithString:[self getAuthorStringWithFinalDelimiter:@"and"]];
    NSString* yearstr = [fields valueForKey:YEAR];
    if (authorArray.count>0 && yearstr.length>0) {
        [out appendFormat:@" (%@)", yearstr];
    }else if (yearstr.length){
        [out appendFormat:@"(%@)", yearstr];
    }
    return out;
}


-(NSString *)getAuthorStringWithFinalDelimiter:(NSString *)delimit{
    NSString* out = @"";
    for (NSInteger i=0; i<authorArray.count;i++){
        Name* name = [authorArray objectAtIndex:i];
        out = [out stringByAppendingString:[name surnameWithInitials]];
        if (i==authorArray.count-1) {
            break;
        }else if (i==authorArray.count-2){
            if ([[authorArray objectAtIndex:i+1]isEtAl] || !delimit) {
                out = [out stringByAppendingString:@", "];
            }else{
                out = [out stringByAppendingString: [NSString stringWithFormat:@" %@ ", delimit]];
            }
        }else{
            out = [out stringByAppendingString:@", "];
        }
    }
    return out;
}

-(NSString*)getTexString{
    return bibTexString;
}



#pragma mark Editing

-(void)setType:(NSString *)typ{
    type=typ;
    NSArray* arr = [Reference getEstablishedFields];
    NSMutableArray* newKeys = [[NSMutableArray alloc]initWithArray:[Reference getCorrespondingPrincipleFields:type]];
    for (NSInteger i=0; i<arr.count; i++){
        NSString* ky =[arr objectAtIndex:i];
        if (![newKeys containsObject:ky]) [newKeys addObject:ky];
    }
    for (NSInteger i=0; i<keys.count; i++){
        NSString* ky =[keys objectAtIndex:i];
        if (![newKeys containsObject:ky]) [newKeys addObject:ky];
    }
    keys = newKeys;
}

-(void)modifyField:(NSString *)newval forKey:(NSString *)ky isTexFormat:(BOOL)tex{
    if ([ky isEqualToString:YEAR]) {
        yearInt = [newval integerValue];
    }
    if (tex) {
        [texFields setValue:newval forKey:ky];
        bibTexString = [self privateMakeTexString];
        @try {
            NSString* newvalstandard = [TeXTranslator translateTexToAttributedString:newval].string;
            [fields setValue:newvalstandard forKey:ky];
        }
        @catch (NSException *exception) {
            [fields setValue:newval forKey:ky];
        }
        if ([ky isEqualToString:AUTHOR]) {
            authorArray = [self makeNameArray:newval];
        }else if ([ky isEqualToString:EDITOR]){
            editorArray = [self makeNameArray:newval];
        }        
    }else{
        [fields setValue:newval forKey:ky];
        @try {
            [texFields setValue:[TeXTranslator translateStringToTex:newval] forKey:ky];
        }
        @catch (NSException *exception) {
            [texFields setValue:newval forKey:ky];
        }
        if ([ky isEqualToString:AUTHOR]) {
            authorArray = [self makeNameArray:newval];
        }else if ([ky isEqualToString:EDITOR]){
            editorArray = [self makeNameArray:newval];
        }
        bibTexString = [self privateMakeTexString];
    }
}

-(NSString*)addFieldValueNullable:(NSString *)val forKeyNullable:(NSString *)ky isTexFormat:(BOOL)tex{
    if (!val) val = @"";
    if (!ky) {
        int i=0;
        do {
            i++;
            ky = [NSString stringWithFormat:@"field_key_%d", i];
        } while ([fields.allKeys containsObject:ky]);
    }
    [keys addObject:ky];
    if (tex) {
        [texFields setObject:val forKey:ky];
        bibTexString = [self privateMakeTexString];
        @try {
            [fields setObject:[TeXTranslator translateTexToAttributedString:val].string forKey:ky];
        }
        @catch (NSException *exception) {
            [fields setObject:val forKey:ky];
        }
    }else{
        [fields setObject:val forKey:ky];
        @try {
            [texFields setObject:[TeXTranslator translateStringToTex:val] forKey:ky];
        }
        @catch (NSException *exception) {
            [texFields setObject:val forKey:ky];
        }
        bibTexString = [self privateMakeTexString];
    }
    return ky;
}

-(NSString *)privateMakeTexString{
    if (keyAutoGenerated || key.length==0) {
        NSString* firtAuthor;
        if (authorArray.count) {
            firtAuthor = [[authorArray firstObject].surname lowercaseString];
        }else firtAuthor = @"someone";
        NSString* year = [fields valueForKey:YEAR];
        if (!year.length) year = @"Sometime";
        NSString* title = [[fields valueForKey:TITLE]capitalizedString];
        if (!title.length) {
            title = @"Something";
        }else if (title.length>20){
            NSInteger i = 20;
            for (; i>=0; i--) {
                if ([[NSCharacterSet whitespaceAndNewlineCharacterSet]characterIsMember:[title characterAtIndex:i]]) {
                    break;
                }
            }
            if (i==0) {
                title = [title substringToIndex:20];
                title = [[title componentsSeparatedByCharactersInSet:[[NSCharacterSet alphanumericCharacterSet]invertedSet]]componentsJoinedByString:@""];
            }else{
                title = [title substringToIndex:i];
                title = [[title componentsSeparatedByCharactersInSet:[[NSCharacterSet alphanumericCharacterSet]invertedSet]]componentsJoinedByString:@""];
            }
        }else{
            title = [[title componentsSeparatedByCharactersInSet:[[NSCharacterSet alphanumericCharacterSet]invertedSet]]componentsJoinedByString:@""];
        }
        key = [NSString stringWithFormat:@"%@%@%@", firtAuthor, year, title];
    }
    NSString* out = [NSString stringWithFormat:@"@%@{%@,\n", type, key];
    for (NSInteger m=0; m<texFields.allKeys.count; m++){
        NSString* ky =[texFields.allKeys objectAtIndex:m];
        NSString* val = [texFields valueForKey:ky];
        if (val.length==0) continue;
        out = [out stringByAppendingString:[NSString stringWithFormat:@"\t%@ = {%@},\n", ky, val]];
    }
    out = [out stringByAppendingString:@"}"];
    return out;
}

# pragma mark Handy Static Methods

+(NSArray *)getEntryTypes{
    return [[NSArray alloc]initWithObjects:@"article", @"book", @"booklet", @"conference", @"inbook", @"incollection", @"inproceedings", @"manual", @"masterthesis", @"misc", @"phdthesis", @"proceedings", @"techreport", @"unpublished", nil];
}

+(NSArray*)getEstablishedFields{
    return [[NSArray alloc]initWithObjects:AUTHOR,ADDRESS,ANNOTE,BOOKTITLE,CHAPTER,CROSSREF,EDITION,EDITOR, HOWPUBLISHED, INSTITUTION, JOURNAL, MONTH,NOTE,NUMBER, ORGANIZATION, PAGES,PUBLISHER,SCHOOL, SERIES,TITLE, VOLUME, YEAR, nil];
}

+(NSArray*)articleFields{
    return [[NSArray alloc]initWithObjects:AUTHOR, TITLE, JOURNAL, YEAR, VOLUME, NUMBER, PAGES, MONTH, nil];
}
+(NSArray*)bookFields{
    return [[NSArray alloc]initWithObjects:TITLE, PUBLISHER, YEAR, AUTHOR, EDITOR, VOLUME, NUMBER, SERIES, ADDRESS, EDITION, MONTH, nil];
}
+(NSArray*)bookletFields{
    return [[NSArray alloc]initWithObjects:TITLE, AUTHOR, HOWPUBLISHED, ADDRESS, MONTH, YEAR, nil];
}
+(NSArray*)conferenceFields{
    return [[NSArray alloc]initWithObjects:AUTHOR, TITLE, BOOKTITLE, YEAR, EDITOR, VOLUME, PAGES, NUMBER, ORGANIZATION, SERIES, PUBLISHER, ADDRESS,MONTH, nil];
}
+(NSArray*)inbookFields{
    return [[NSArray alloc]initWithObjects:TITLE, PUBLISHER, YEAR, AUTHOR, EDITOR, CHAPTER, NUMBER, VOLUME, SERIES, MONTH, ADDRESS, EDITION, PAGES, nil];
}
+(NSArray*)incollectionFields{
    return [[NSArray alloc]initWithObjects:TITLE, PUBLISHER, YEAR, AUTHOR, EDITOR, VOLUME, NUMBER, SERIES, ADDRESS, EDITION, MONTH, nil];
}
+(NSArray*)inproceedingsFields{
    return [[NSArray alloc]initWithObjects:AUTHOR, TITLE, BOOKTITLE, YEAR, EDITOR, VOLUME, PAGES, NUMBER,ORGANIZATION, SERIES, PUBLISHER, ADDRESS, MONTH, nil];
}
+(NSArray*)manualFields{
    return [[NSArray alloc]initWithObjects:TITLE, AUTHOR, ORGANIZATION, ADDRESS, EDITION, MONTH, YEAR, nil];
}
+(NSArray*)masterthesisFields{
    return [[NSArray alloc]initWithObjects:AUTHOR, TITLE, SCHOOL, YEAR, ADDRESS, MONTH, nil];
}
+(NSArray*)miscFields{
    return [[NSArray alloc]initWithObjects:TITLE, HOWPUBLISHED, AUTHOR, MONTH, YEAR, nil];
}
+(NSArray*)phdthesisFields{
    return [[NSArray alloc]initWithObjects:AUTHOR, TITLE, SCHOOL, YEAR, ADDRESS, MONTH, nil];
}
+(NSArray*)proceedingsFields{
    return [[NSArray alloc]initWithObjects:TITLE, YEAR, EDITOR, NUMBER, PUBLISHER, ORGANIZATION, ADDRESS, MONTH, VOLUME, nil];
}
+(NSArray*)techreportFields{
    return [[NSArray alloc]initWithObjects:AUTHOR, TITLE, INSTITUTION, YEAR, NUMBER, ADDRESS, MONTH, nil];
}
+(NSArray*)unpublishedFields{
    return [[NSArray alloc]initWithObjects:AUTHOR, NOTE, TITLE, MONTH, YEAR, nil];
}
+(NSArray*)getCorrespondingPrincipleFields:(NSString *)type{
    if ([type isEqualToString:@"article"]) {
        return [Reference articleFields];
    }else if ([type isEqualToString:@"book"]){
        return [Reference bookFields];
    }else if ([type isEqualToString:@"booklet"]){
        return [Reference bookletFields];
    }else if ([type isEqualToString:@"conference"]){
        return [Reference conferenceFields];
    }else if ([type isEqualToString:@"inbook"]){
        return [Reference inbookFields];
    }else if ([type isEqualToString:@"incollection"]){
        return [Reference incollectionFields];
    }else if ([type isEqualToString:@"inproceedings"]){
        return [Reference inproceedingsFields];
    }else if ([type isEqualToString:@"manual"]){
        return [Reference manualFields];
    }else if ([type isEqualToString:@"masterthesis"]){
        return [Reference masterthesisFields];
    }else if ([type isEqualToString:@"misc"]){
        return [Reference miscFields];
    }else if ([type isEqualToString:@"phdthesis"]){
        return [Reference phdthesisFields];
    }else if ([type isEqualToString:@"proceedings"]){
        return [Reference proceedingsFields];
    }else if ([type isEqualToString:@"techreport"]){
        return [Reference techreportFields];
    }else if ([type isEqualToString:@"unpublished"]){
        return [Reference unpublishedFields];
    }else return [Reference getEstablishedFields];
}


+(NSMutableArray*)makeArrayOfNames:(NSString *)names{
    NSArray * ar1 = [names componentsSeparatedByString:@" and "];
    NSMutableArray * ar2 = [[NSMutableArray alloc]init];
    NSMutableArray * out = [[NSMutableArray alloc]init];

    for (NSInteger k=0; k<ar1.count; k++){
        NSString* name = [ar1 objectAtIndex:k];
        int rangeStart, rangeLength=0;
        NSString* trimmedName;
        for (int i=0; i<name.length; i++) {
            unichar c = [name characterAtIndex:i];
            if (c==' ' || c=='\t' || c=='\n') continue;
            else if (i==name.length-1) return nil;
            else{
                rangeStart = i; break;
            }
        }
        for (int i=rangeStart; i<name.length; i++) {
            rangeLength++;
        }
        trimmedName = [name substringWithRange:NSMakeRange(rangeStart,rangeLength)];
        [ar2 addObject:trimmedName];
    }
    return out;
}


+(NSMutableArray*)getReferencesFromFile:(NSString *)path{
    NSString* longString = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];
    NSMutableArray* refStrings = [Reference getReferenceStringsFromWhole:longString];
    NSMutableArray* references = [[NSMutableArray alloc]initWithCapacity:refStrings.count];
    for (NSInteger i=0; i<refStrings.count; i++) {
        NSString* refString = [refStrings objectAtIndex:i];
        [references addObject:[[Reference alloc]initWithBibEntry:refString]];
    }
    return references;
}



+(NSMutableArray*)getReferenceStringsFromWhole:(NSString*)wholeString{
    NSInteger i;
    NSArray* keys = [Reference getEntryTypes];
    NSCharacterSet * emptychars = [NSCharacterSet whitespaceAndNewlineCharacterSet];
    NSMutableArray* stringReferences = [[NSMutableArray alloc]init];
    
    for (i=0; TRUE; i++) {
        if (i==wholeString.length){
            goto break_loop;
        }
        unichar c = [wholeString characterAtIndex:i];
        if (c=='@') {
            for (NSInteger j=i+1; TRUE; j++) {
                if (j==wholeString.length){
                    goto break_loop;
                }
                unichar d = [wholeString characterAtIndex:j];
                if (d=='@') {
                    i=j-1;
                    goto end_of_loop;
                }else if (d=='{'){
                    NSString *key = [wholeString substringWithRange:NSMakeRange(i+1, j-i-1)];
                    key = [key stringByTrimmingCharactersInSet:emptychars];
                    if ([keys containsObject:key]) {
                        int lr=1;
                        j++;
                        while (TRUE) {
                            if (j==wholeString.length) {
                                goto end_of_loop;
                            }
                            if([wholeString characterAtIndex:j]=='{') lr++;
                            else if ([wholeString characterAtIndex:j]=='}') lr--;
                            
                            if (lr==0) { //we have what we want!
                                NSString* stringref = [wholeString substringWithRange:NSMakeRange(i+1, j-i)];
                                [stringReferences addObject:stringref];
                                i=j;
                                goto end_of_loop;
                            }
                            j++;
                        }
                    }else{
                        i=j;
                        goto end_of_loop;
                    }
                }
                
            }
        }
        end_of_loop: continue;
    }
break_loop:
    
    return stringReferences;
}


#pragma mark Comparators

-(BOOL)isEqualToReference:(Reference *)ref{
    if (ref.authorArray.count!=self.authorArray.count) return FALSE;
    if (![[ref.fields valueForKey:YEAR] isEqualToString:[self.fields valueForKey:YEAR]]) return FALSE;
    if (![ref.type isEqualToString: self.type]) return FALSE;
    
    
    NSString* title1 = [[self.fields valueForKey:TITLE]lowercaseString];
    NSString* title2 = [[ref.fields valueForKey:TITLE]lowercaseString];
    
    if (title1 && title2 && ![title1 isEqualToString:title2]) return FALSE;
    
    for (NSInteger i=0; i<self.authorArray.count; i++) {
        Name* n1 = [self.authorArray objectAtIndex:i];
        Name* n2 = [ref.authorArray objectAtIndex:i];
        if (![n1 isEqualToName:n2]) return FALSE;
    }
    return TRUE;
}

-(NSComparisonResult)compare:(Reference*)ref byFields:(NSArray<NSString*>*)compareKeys{
    for (NSInteger i=0; i<compareKeys.count; i++) {
        NSComparisonResult out=NSOrderedSame;
        NSString* compKey = [compareKeys objectAtIndex:i];
        if ([compKey isEqualToString:AUTHOR] || [compKey isEqualToString:EDITOR]) {
            NSArray* thesenames = [compKey isEqualToString:AUTHOR]? authorArray:editorArray;
            NSArray* thosenames = [compKey isEqualToString:AUTHOR]? ref.authorArray:ref.editorArray;
            NSInteger cap =(thesenames.count<=thosenames.count)?thesenames.count:thosenames.count;
            for (NSInteger i = 0; i<cap; i++) {
                NSString* thisname = [[thesenames objectAtIndex:i]surnameWithInitials];
                NSString* thatname = [[thosenames objectAtIndex:i]surnameWithInitials];
                NSComparisonResult comp = [thisname compare:thatname];
                if (comp!=NSOrderedSame) return comp;
            }
            if (thesenames.count>thosenames.count) return NSOrderedDescending;
            else if (thesenames.count<thosenames.count)  return NSOrderedAscending;
        }else{
            NSString* thisval = [fields objectForKey:compKey];
            NSString* thatval = [ref.fields objectForKey:compKey];
            out = [thisval compare:thatval];
        }
        if (out!=NSOrderedSame) return out;
    }
    return NSOrderedSame;
}

-(NSComparisonResult)compare:(Reference*)ref{
    return [self compare:ref byFields:@[AUTHOR, YEAR]];
}

+(void)sortArray:(NSMutableArray<Reference *> *)refs withFields:(NSArray<NSString *> *)keys{
    [refs sortUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) {
        Reference* r1 = (Reference*)obj1;
        Reference* r2 = (Reference*)obj2;
        NSComparisonResult result = [r1 compare:r2 byFields:keys];
        return result;
    }];
//    BOOL repeat;
//    do {
//        repeat = false;
//        for (NSInteger i=0; i+1<refs.count; i++) {
//            Reference* r1 = [refs objectAtIndex:i];
//            Reference* r2 = [refs objectAtIndex:i+1];
//            NSComparisonResult comp = [r1 compare:r2 byFields:keys];
//            if (comp==NSOrderedDescending) {
//                [refs replaceObjectAtIndex:i withObject:r2];
//                [refs replaceObjectAtIndex:i+1 withObject:r1];
//                repeat=true;
//            }
//        }
//    } while (repeat);
}














@end
